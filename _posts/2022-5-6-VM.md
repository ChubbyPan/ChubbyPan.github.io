## 为什么出现了VM?
从进程隔离的角度进行思考
- 没出现VM之前,进程怎么工作? 可不可以并发?
<!-- 在虚拟地址出现之前,进程可以直接访问存储单元; 比如单片机的CPU就可以直接对物理地址进行处理,这就会导致不能同时运行多个程序(举个例子,地址更改);所以出现了虚拟地址,每个进程都有自己的\独立的虚拟地址,在表面上拥有了整个地址空间,进程运行时,CPU会给出虚拟地址,通过MMU映射到对应的物理地址当中,使得进程并不会直接对物理内存操作,因为虚拟内存的存在,各个进程之间可以实现在运行时互相不干涉. -->
## OS怎么管理虚拟地址和物理地址? **(说说内存管理)**
可以利用内存分段来管理
- 怎么分段? (程序逻辑段,栈段、堆段、数据段、代码段)
- VM地址空间组成? 
- VM地址结构? 
- 怎么映射? 
- 带来了什么问题? 
- 怎么解决带来的问题? 内存碎片,swap->用内存分页来解决

也可以用内存分页来管理
- 为什么分页?(解决分段带来的内存碎片和内存交换效率太低的问题)
- 怎么解决?
- 页多大?固定嘛?
- 虚拟地址长什么样?怎么进行地址映射?
- 单级页表带来什么问题?(进程有很多的话会发生什么事情?)
- 多级页表 容量更大,存在内存当中不会更浪费么?
    - 程序的局部性原理 实际存储下来的容量不大
- 多级页表有什么问题? 怎么解决?
  - 多次转换->慢
  - TLB 
  - TLB和页表的区别? 分别存储在哪里?

也可以用段页式内存管理
- 怎么实现?
  - 先分段,再分页
- 地址结构?
  - 段号,段内页号,页offset
- translate过程?
  
## Linux怎么实现内存管理?
- 采用什么方式? 页式还是段式?
- 虚拟地址结构?
  - 内核 + 用户空间
  - 这两个有什么区别?
- 用户空间怎么划分? ->进程的虚拟地址结构长什么样?
- 分为几块,每一块有什么作用?
  - 这里可以衍生linking的时候,ELF文件的各个section分别映射到虚拟内存的哪几个部分当中